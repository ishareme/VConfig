'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var fs = _interopDefault(require('fs-extra'));
var rollupPluginutils = require('rollup-pluginutils');
var styleInject = _interopDefault(require('style-inject'));
var Concat = _interopDefault(require('concat-with-sourcemaps'));
var series = _interopDefault(require('promise.series'));
var postcss = _interopDefault(require('postcss'));
var findPostcssConfig = _interopDefault(require('postcss-load-config'));
var reserved = _interopDefault(require('reserved-words'));
var pify = _interopDefault(require('pify'));

const localRequire = name => require(path.resolve('node_modules', name));

function loadConfig(id, { ctx: configOptions, path: configPath }) {
  const handleError = err => {
    if (err.message.indexOf('No PostCSS Config found') === -1) {
      throw err;
    }
    // Return empty options for PostCSS
    return {};
  };

  configPath = configPath ? path.resolve(configPath) : path.dirname(id);
  const ctx = {
    file: {
      extname: path.extname(id),
      dirname: path.dirname(id),
      basename: path.basename(id)
    },
    options: configOptions || {}
  };

  return findPostcssConfig(ctx, configPath, { argv: false }).catch(handleError);
}

function escapeClassNameDashes(str) {
  return str.replace(/-+/g, match => `$${match.replace(/-/g, '_')}$`);
}

function ensureClassName(name) {
  name = escapeClassNameDashes(name);
  if (reserved.check(name)) {
    name = `$${name}$`;
  }
  return name;
}

function ensurePostCSSOption(option) {
  return typeof option === 'string' ? localRequire(option) : option;
}

var postcssLoader = {
  name: 'postcss',
  test: /\.(css|sss)$/,
  process({ code, map }) {
    return new Promise(function ($return, $error) {
      var config, options, plugins, shouldExtract, shouldInject, modulesExported, postcssOpts, res, json, newName;
      let output, extracted;

      if (!this.sourceMap && map) {
        console.warn(`\n\n ⚠️  rollup-plugin-postcss\n\nPrevious source map found, but options.sourceMap isn't set.\nIn this case the loader will discard the source map entirely for performance reasons.\n\n`);
      }

      return new Promise(function ($return, $error) {
        if (this.options.config) {
          return loadConfig(this.id, this.options.config).then($return, $error);
        }return $return({});
      }.bind(this)).then(function ($await_4) {
        try {
          config = $await_4;
          options = this.options;
          plugins = [...(options.postcss.plugins || []), ...(config.plugins || [])];
          shouldExtract = options.extract;
          shouldInject = options.inject;
          modulesExported = {};

          if (options.modules) {
            plugins.unshift(require('postcss-modules')(Object.assign({
              generateScopedName: '[name]_[local]__[hash:base64:5]'
            }, options.modules, {
              getJSON(filepath, json) {
                modulesExported[filepath] = json;
              }
            })));
          }

          if (options.minimize) {
            plugins.push(require('cssnano')(options.minimize));
          }

          postcssOpts = Object.assign({}, this.options.postcss, config.options, {
            // Followings are never modified by user config config
            from: this.id,
            to: this.id,
            map: this.sourceMap ? shouldExtract ? { inline: false, annotation: false } : { inline: true, annotation: false } : false
          });

          delete postcssOpts.plugins;

          postcssOpts.parser = ensurePostCSSOption(postcssOpts.parser);
          postcssOpts.syntax = ensurePostCSSOption(postcssOpts.syntax);
          postcssOpts.stringifier = ensurePostCSSOption(postcssOpts.stringifier);

          if (map && postcssOpts.map) {
            postcssOpts.map.prev = typeof map === 'string' ? JSON.parse(map) : map;
          }

          return postcss(plugins).process(code, postcssOpts).then(function ($await_5) {
            try {
              res = $await_5;


              output = '';


              if (options.namedExports) {
                json = modulesExported[this.id];

                // eslint-disable-next-line guard-for-in
                for (const name in json) {
                  newName = ensureClassName(name);

                  if (name !== newName) {
                    console.warn(`Exported "${name}" as "${newName}" in ${path.relative(process.cwd(), this.id)}`);
                  }
                  output += `export var ${newName} = ${JSON.stringify(json[name])};\n`;
                }
              }

              if (shouldExtract) {
                output += `export default ${JSON.stringify(modulesExported[this.id])};`;
                extracted = {
                  id: this.id,
                  code: res.css,
                  map: res.map
                };
              } else {
                output += `var css = ${JSON.stringify(res.css)};\nexport default ${options.modules ? JSON.stringify(modulesExported[this.id]) : 'css'};`;
              }
              if (!shouldExtract && shouldInject) {
                output += `\n__$$styleInject(css${Object.keys(options.inject).length > 0 ? `,${JSON.stringify(options.inject)}` : ''});`;
              }

              return $return({
                code: output,
                map: res.map,
                extracted
              });
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }.bind(this), $error);
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }.bind(this), $error);
    }.bind(this));
  }
};

var sassLoader = {
  name: 'sass',
  test: /\.s[ac]ss$/,
  process({ code }) {
    return new Promise(function ($return, $error) {
      var sass, res;
      sass = localRequire('node-sass');
      return pify(sass.render.bind(sass))(Object.assign({}, this.options, {
        file: this.id,
        data: code,
        indentedSyntax: /\.sass$/.test(this.id),
        sourceMap: this.sourceMap
      })).then(function ($await_1) {
        try {
          res = $await_1;


          return $return({
            code: res.css.toString(),
            map: res.map && res.map.toString()
          });
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }.bind(this), $error);
    }.bind(this));
  }
};

class Loaders {
  constructor(options = {}) {
    this.use = options.use;
    this.loaders = [];

    this.registerLoader(postcssLoader);
    this.registerLoader(sassLoader);
    if (options.loaders) {
      options.loaders.forEach(loader => this.registerLoader(loader));
    }
  }

  registerLoader(loader) {
    const existing = this.getLoader(loader.name);
    if (existing) {
      this.removeLoader(loader.name);
    }
    this.loaders.push(loader);
    return this;
  }

  removeLoader(name) {
    this.loaders = this.loaders.filter(loader => loader.name !== name);
    return this;
  }

  isSupported(filepath) {
    return this.loaders.some(loader => {
      return loader.test.test(filepath);
    });
  }

  process({ code, map, id, sourceMap }) {
    const names = Object.keys(this.use);
    return series(names.slice().reverse().map(name => {
      const loader = this.getLoader(name);
      const options = this.use[name];
      const loaderContext = {
        options,
        id,
        sourceMap
      };
      return v => {
        // Only process if it's postcss loader
        // Or passed `test`
        if (name === 'postcss' || loader.test.test(id)) {
          return loader.process.call(loaderContext, v);
        }
        // Otherwise directly return input value
        return v;
      };
    }), { code, map });
  }

  getLoader(name) {
    return this.loaders.find(loader => loader.name === name);
  }
}

/**
 * The options that could be `boolean` or `object`
 * We convert it to an object when it's truthy
 * Otherwise fallback to default value
 */
function inferOption(option, defaultValue) {
  if (option === false) { return false; }
  if (option && typeof option === 'object') { return option; }
  return option ? {} : defaultValue;
}

var index = ((options = {}) => {
  const filter = rollupPluginutils.createFilter(options.include, options.exclude);
  const sourceMap = options.sourceMap;
  const postcssLoaderOptions = {
    /** Inject CSS as `<style>` to `<head>` */
    inject: inferOption(options.inject, {}),
    /** Extract CSS */
    extract: typeof options.extract === 'undefined' ? false : options.extract,
    /** CSS modules */
    modules: inferOption(options.modules, false),
    namedExports: options.namedExports,
    /** Options for cssnano */
    minimize: inferOption(options.minimize, false),
    /** Postcss config file */
    config: inferOption(options.config, {}),
    /** PostCSS options */
    postcss: {
      parser: options.parser,
      plugins: options.plugins,
      syntax: options.syntax,
      stringifier: options.stringifier,
      exec: options.exec
    }
  };
  let use = options.use || [];
  use.unshift(['postcss', postcssLoaderOptions]);
  use = use.reduce((res, rule) => {
    if (typeof rule === 'string') {
      rule = [rule];
    }
    const name = rule[0];
    const options = rule[1] || {};

    res[name] = options;
    return res;
  }, {});

  const loaders = new Loaders({
    use,
    loaders: options.loaders
  });

  let extracted = [];

  return {
    name: 'postcss',

    intro() {
      if (!postcssLoaderOptions.inject || postcssLoaderOptions.extract) { return; }
      return styleInject.toString().replace('styleInject', '__$$$$styleInject');
    },

    transform(code, id) {
      return new Promise(function ($return, $error) {
        var res;

        if (!filter(id) || !loaders.isSupported(id)) {
          return $return(null);
        }

        if (typeof options.onImport === 'function') {
          options.onImport(id);
        }

        return loaders.process({
          code,
          map: undefined,
          id,
          sourceMap
        }).then(function ($await_1) {
          try {
            res = $await_1;


            if (postcssLoaderOptions.extract) {
              extracted.push(res.extracted);
              return $return({
                code: res.code,
                map: { mappings: '' }
              });
            }

            return $return({
              code: res.code,
              map: res.map ? JSON.parse(res.map.toString()) : { mappings: '' }
            });
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }.bind(this), $error);
      }.bind(this));
    },

    onwrite(opts) {
      return new Promise(function ($return, $error) {
        var basename, file, concat, relative, map;
        let code;

        if (extracted.length === 0) { return $return(); }

        basename = path.basename(opts.file, path.extname(opts.file));
        file = path.relative(process.cwd(), path.join(path.dirname(opts.file), basename + '.css'));
        concat = new Concat(true, file, '\n');

        for (var i = 0, list = extracted; i < list.length; i += 1) {
          const res = list[i];

          relative = path.relative(process.cwd(), res.id);
          map = res.map ? JSON.parse(res.map.toString()) : null;

          if (map) {
            map.file = file;
            map.sources = map.sources.map(source => path.relative(process.cwd(), path.join(path.dirname(opts.file), source)));
          }
          concat.add(relative, res.code, map);
        }
        code = concat.content;

        if (sourceMap === 'inline') {
          code += `\n/*# sourceMappingURL=data:application/json;base64,${Buffer.from(concat.sourceMap, 'utf8').toString('base64')}*/`;
        } else if (sourceMap === true) {
          code += `\n/*# sourceMappingURL=${basename}.css.map */`;
        }

        return Promise.all([fs.writeFile(file, code, 'utf8'), sourceMap === true && fs.writeFile(file + '.map', concat.sourceMap, 'utf8')]).then(function ($await_2) {
          try {

            // Release for potential next build
            extracted = [];
            return $return();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }.bind(this), $error);
      }.bind(this));
    }
  };
});

module.exports = index;
